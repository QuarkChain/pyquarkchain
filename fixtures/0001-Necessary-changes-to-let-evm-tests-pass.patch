diff --git a/quarkchain/config.py b/quarkchain/config.py
index 8b6b1dc..46ebc4c 100644
--- a/quarkchain/config.py
+++ b/quarkchain/config.py
@@ -547,4 +547,4 @@ class QuarkChainConfig(BaseConfig):
 
 
 def get_default_evm_config():
-    return dict(quarkchain.evm.config.default_config)
+    return dict(quarkchain.evm.config.config_metropolis)
diff --git a/quarkchain/evm/config.py b/quarkchain/evm/config.py
index 7f2e403..8f8f232 100644
--- a/quarkchain/evm/config.py
+++ b/quarkchain/evm/config.py
@@ -2,6 +2,7 @@ from quarkchain.rlp.utils import decode_hex
 
 from quarkchain.evm import utils
 from quarkchain.db import InMemoryDb, Db
+import copy
 
 
 default_config = dict(
@@ -10,12 +11,12 @@ default_config = dict(
     # Genesis block gas limit
     GENESIS_GAS_LIMIT=3141592,
     # Genesis block prevhash, coinbase, nonce
-    GENESIS_PREVHASH=b"\x00" * 32,
-    GENESIS_COINBASE=b"\x00" * 20,
+    GENESIS_PREVHASH=b'\x00' * 32,
+    GENESIS_COINBASE=b'\x00' * 20,
     GENESIS_NONCE=utils.zpad(utils.encode_int(42), 8),
-    GENESIS_MIXHASH=b"\x00" * 32,
+    GENESIS_MIXHASH=b'\x00' * 32,
     GENESIS_TIMESTAMP=0,
-    GENESIS_EXTRA_DATA=b"",
+    GENESIS_EXTRA_DATA=b'',
     GENESIS_INITIAL_ALLOC={},
     # Minimum gas limit
     MIN_GAS_LIMIT=5000,
@@ -51,18 +52,91 @@ default_config = dict(
     # Exponential difficulty timebomb period
     EXPDIFF_PERIOD=100000,
     EXPDIFF_FREE_PERIODS=2,
+    # Delay in Byzantium
+    METROPOLIS_DELAY_PERIODS=30,
     # Blank account initial nonce
     ACCOUNT_INITIAL_NONCE=0,
+    # Homestead fork
+    HOMESTEAD_FORK_BLKNUM=1150000,
+    HOMESTEAD_DIFF_ADJUSTMENT_CUTOFF=10,
+    # Metropolis fork
+    METROPOLIS_FORK_BLKNUM=4370000,
+    METROPOLIS_ENTRY_POINT=2 ** 160 - 1,
+    METROPOLIS_STATEROOT_STORE=0x10,
+    METROPOLIS_BLOCKHASH_STORE=0x20,
+    METROPOLIS_WRAPAROUND=65536,
+    METROPOLIS_GETTER_CODE=decode_hex('6000355460205260206020f3'),
+    METROPOLIS_DIFF_ADJUSTMENT_CUTOFF=9,
+    # Constantinople fork
+    CONSTANTINOPLE_FORK_BLKNUM=2**100,
+    # DAO fork
+    DAO_FORK_BLKNUM=1920000,
+    DAO_FORK_BLKHASH=decode_hex(
+        '4985f5ca3d2afbec36529aa96f74de3cc10a2a4a6c44f2157a57d2c6059a11bb'),
+    DAO_FORK_BLKEXTRA=decode_hex('64616f2d686172642d666f726b'),
+    DAO_WITHDRAWER=utils.normalize_address(
+        '0xbf4ed7b27f1d666546e30d74d50d173d20bca754'),
+    # Anti-DoS fork
+    ANTI_DOS_FORK_BLKNUM=2463000,
+    SPURIOUS_DRAGON_FORK_BLKNUM=2675000,
+    CONTRACT_CODE_SIZE_LIMIT=0x6000,
+    # Default consensus strategy: ethash, poa, casper, pbft
+    CONSENSUS_STRATEGY='ethash',
+    # Serenity fork
+    SERENITY_FORK_BLKNUM=2**99,
     PREV_HEADER_DEPTH=256,
+    SYSTEM_ENTRY_POINT=utils.int_to_addr(2**160 - 2),
+    SERENITY_HEADER_VERIFIER=utils.int_to_addr(255),
+    SERENITY_HEADER_POST_FINALIZER=utils.int_to_addr(254),
+    SERENITY_GETTER_CODE=decode_hex(
+        '60ff331436604014161560155760203560003555005b6000355460205260206020f3'),
     # Custom specials
     CUSTOM_SPECIALS={},
 )
-assert default_config["NEPHEW_REWARD"] == default_config["BLOCK_REWARD"] // 32
+assert default_config['NEPHEW_REWARD'] == \
+    default_config['BLOCK_REWARD'] // 32
 
 
 class Env(object):
+
     def __init__(self, db=None, config=None, global_config=None):
         self.db = InMemoryDb() if db is None else db
         assert isinstance(self.db, Db)
         self.config = config or dict(default_config)
         self.global_config = global_config or dict()
+
+
+config_frontier = copy.copy(default_config)
+config_frontier["HOMESTEAD_FORK_BLKNUM"] = 2**99
+config_frontier["ANTI_DOS_FORK_BLKNUM"] = 2**99
+config_frontier["SPURIOUS_DRAGON_FORK_BLKNUM"] = 2**99
+config_frontier["METROPOLIS_FORK_BLKNUM"] = 2**99
+config_frontier["CONSTANTINOPLE_FORK_BLKNUM"] = 2**99
+
+config_homestead = copy.copy(default_config)
+config_homestead["HOMESTEAD_FORK_BLKNUM"] = 0
+config_homestead["ANTI_DOS_FORK_BLKNUM"] = 2**99
+config_homestead["SPURIOUS_DRAGON_FORK_BLKNUM"] = 2**99
+config_homestead["METROPOLIS_FORK_BLKNUM"] = 2**99
+config_homestead["CONSTANTINOPLE_FORK_BLKNUM"] = 2**99
+
+config_tangerine = copy.copy(default_config)
+config_tangerine["HOMESTEAD_FORK_BLKNUM"] = 0
+config_tangerine["ANTI_DOS_FORK_BLKNUM"] = 0
+config_tangerine["SPURIOUS_DRAGON_FORK_BLKNUM"] = 2**99
+config_tangerine["METROPOLIS_FORK_BLKNUM"] = 2**99
+config_tangerine["CONSTANTINOPLE_FORK_BLKNUM"] = 2**99
+
+config_spurious = copy.copy(default_config)
+config_spurious["HOMESTEAD_FORK_BLKNUM"] = 0
+config_spurious["ANTI_DOS_FORK_BLKNUM"] = 0
+config_spurious["SPURIOUS_DRAGON_FORK_BLKNUM"] = 0
+config_spurious["METROPOLIS_FORK_BLKNUM"] = 2**99
+config_spurious["CONSTANTINOPLE_FORK_BLKNUM"] = 2**99
+
+config_metropolis = copy.copy(default_config)
+config_metropolis["HOMESTEAD_FORK_BLKNUM"] = 0
+config_metropolis["ANTI_DOS_FORK_BLKNUM"] = 0
+config_metropolis["SPURIOUS_DRAGON_FORK_BLKNUM"] = 0
+config_metropolis["METROPOLIS_FORK_BLKNUM"] = 0
+config_metropolis["CONSTANTINOPLE_FORK_BLKNUM"] = 2**99
diff --git a/quarkchain/evm/messages.py b/quarkchain/evm/messages.py
index 8b54065..97e663a 100644
--- a/quarkchain/evm/messages.py
+++ b/quarkchain/evm/messages.py
@@ -6,7 +6,7 @@ import rlp
 # to bypass circular imports
 import quarkchain.core
 
-from quarkchain.evm.utils import int256, safe_ord, bytearray_to_bytestr, add_dict
+from quarkchain.evm.utils import int256, safe_ord, bytearray_to_bytestr
 from rlp.sedes import big_endian_int, binary, CountableList, BigEndianInt
 from rlp.sedes.binary import Binary
 from quarkchain.rlp.utils import decode_hex, encode_hex
@@ -25,7 +25,6 @@ from quarkchain.evm.exceptions import (
     InvalidTransaction,
 )
 from quarkchain.evm.slogging import get_logger
-from quarkchain.utils import token_id_decode
 
 
 null_address = b"\xff" * 20
@@ -115,12 +114,32 @@ def mk_receipt(state, success, logs, contract_address, contract_full_shard_key):
     return o
 
 
+def config_fork_specific_validation(config, blknum, tx):
+    # (1) The transaction signature is valid;
+    _ = tx.sender
+    if _ is None:
+        pass
+    if blknum >= config["CONSTANTINOPLE_FORK_BLKNUM"]:
+        tx.check_low_s_metropolis()
+    else:
+        if tx.sender == null_address:
+            raise InvalidTransaction("EIP86 transactions not available yet")
+        if blknum >= config["HOMESTEAD_FORK_BLKNUM"]:
+            tx.check_low_s_homestead()
+
+    if tx.network_id != config["NETWORK_ID"]:
+        raise InvalidTransaction("Wrong network ID")
+    return True
+
+
 def validate_transaction(state, tx):
 
     # (1) The transaction signature is valid;
     if not tx.sender:  # sender is set and validated on Transaction initialization
         raise UnsignedTransaction(tx)
 
+    assert config_fork_specific_validation(state.config, state.block_number, tx)
+
     # (2) the transaction nonce is valid (equivalent to the
     #     sender account's current nonce);
     req_nonce = 0 if tx.sender == null_address else state.get_nonce(tx.sender)
@@ -133,55 +152,14 @@ def validate_transaction(state, tx):
     if tx.startgas < total_gas:
         raise InsufficientStartGas(rp(tx, "startgas", tx.startgas, total_gas))
 
-    # (4.0) require transfer_token_id and gas_token_id to be in allowed list
-    if tx.transfer_token_id not in state.qkc_config.allowed_transfer_token_ids:
-        raise InsufficientBalance(
-            "{}: token {} is not in allowed transfer_token list".format(
-                tx.__repr__(), token_id_decode(tx.transfer_token_id)
-            )
-        )
-    if tx.gas_token_id not in state.qkc_config.allowed_gas_token_ids:
-        raise InsufficientBalance(
-            "{}: token {} is not in allowed gas_token list".format(
-                tx.__repr__(), token_id_decode(tx.gas_token_id)
-            )
-        )
-
     # (4) the sender account balance contains at least the
     # cost, v0, required in up-front payment.
-    if tx.transfer_token_id == tx.gas_token_id:
-        total_cost = tx.value + tx.gasprice * tx.startgas
-        if state.get_balance(tx.sender, token_id=tx.transfer_token_id) < total_cost:
-            raise InsufficientBalance(
-                rp(
-                    tx,
-                    "token %d balance" % tx.transfer_token_id,
-                    state.get_balance(tx.sender, token_id=tx.transfer_token_id),
-                    total_cost,
-                )
-            )
-    else:
-        if state.get_balance(tx.sender, token_id=tx.transfer_token_id) < tx.value:
-            raise InsufficientBalance(
-                rp(
-                    tx,
-                    "token %d balance" % tx.transfer_token_id,
-                    state.get_balance(tx.sender, token_id=tx.transfer_token_id),
-                    tx.value,
-                )
-            )
-        if (
-            state.get_balance(tx.sender, token_id=tx.gas_token_id)
-            < tx.gasprice * tx.startgas
-        ):
-            raise InsufficientBalance(
-                rp(
-                    tx,
-                    "token %d balance" % tx.gas_token_id,
-                    state.get_balance(tx.sender, token_id=tx.gas_token_id),
-                    tx.gasprice * tx.startgas,
-                )
-            )
+    total_cost = tx.value + tx.gasprice * tx.startgas
+
+    if state.get_balance(tx.sender) < total_cost:
+        raise InsufficientBalance(
+            rp(tx, "balance", state.get_balance(tx.sender), total_cost)
+        )
 
     # check block gas limit
     if state.gas_used + tx.startgas > state.gas_limit:
@@ -206,7 +184,7 @@ def apply_message(state, msg=None, **kwargs):
     return bytearray_to_bytestr(data) if result else None
 
 
-def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
+def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash=b""):
     """tx_wrapper_hash is the hash for quarkchain.core.Transaction
     TODO: remove quarkchain.core.Transaction wrapper and use evm.Transaction directly
     """
@@ -230,11 +208,8 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
     )
 
     # buy startgas
-    assert (
-        state.get_balance(tx.sender, token_id=tx.gas_token_id)
-        >= tx.startgas * tx.gasprice
-    )
-    state.delta_token_balance(tx.sender, tx.gas_token_id, -tx.startgas * tx.gasprice)
+    assert state.get_balance(tx.sender) >= tx.startgas * tx.gasprice
+    state.delta_balance(tx.sender, -tx.startgas * tx.gasprice)
 
     message_data = vm.CallData([safe_ord(x) for x in tx.data], 0, len(tx.data))
     message = vm.Message(
@@ -248,8 +223,6 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
         from_full_shard_key=tx.from_full_shard_key,
         to_full_shard_key=tx.to_full_shard_key,
         tx_hash=tx_wrapper_hash,
-        transfer_token_id=tx.transfer_token_id,
-        gas_token_id=tx.gas_token_id,
     )
 
     # MESSAGE
@@ -279,17 +252,15 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
             startgas=tx.startgas,
             gas_remained=gas_remained,
         )
-        state.delta_token_balance(
-            tx.sender, tx.gas_token_id, tx.gasprice * gas_remained
-        )
+        state.delta_balance(tx.sender, tx.gasprice * gas_remained)
         fee = (
             tx.gasprice
             * gas_used
             * local_fee_rate.numerator
             // local_fee_rate.denominator
         )
-        state.delta_token_balance(state.block_coinbase, tx.gas_token_id, fee)
-        add_dict(state.block_fee_tokens, {tx.gas_token_id: fee})
+        state.delta_balance(state.block_coinbase, fee)
+        state.block_fee += fee
         output = b""
         success = 0
     # Transaction success
@@ -302,9 +273,7 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
             gas_used -= min(state.refunds, gas_used // 2)
             state.refunds = 0
         # sell remaining gas
-        state.delta_token_balance(
-            tx.sender, tx.gas_token_id, tx.gasprice * gas_remained
-        )
+        state.delta_balance(tx.sender, tx.gasprice * gas_remained)
         # if x-shard, reserve part of the gas for the target shard miner
         fee = (
             tx.gasprice
@@ -312,8 +281,8 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
             * local_fee_rate.numerator
             // local_fee_rate.denominator
         )
-        state.delta_token_balance(state.block_coinbase, tx.gas_token_id, fee)
-        add_dict(state.block_fee_tokens, {tx.gas_token_id: fee})
+        state.delta_balance(state.block_coinbase, fee)
+        state.block_fee += fee
         if tx.to:
             output = bytearray_to_bytestr(data)
         else:
@@ -329,9 +298,13 @@ def apply_transaction(state, tx: transactions.Transaction, tx_wrapper_hash):
     suicides = state.suicides
     state.suicides = []
     for s in suicides:
-        state.set_balances(s, {})
+        state.set_balance(s, 0)
         state.del_account(s)
 
+    # Pre-Metropolis: commit state after every tx
+    if not state.is_METROPOLIS() and not SKIP_MEDSTATES:
+        state.commit()
+
     # Construct a receipt
     r = mk_receipt(state, success, state.logs, contract_address, state.full_shard_key)
     state.logs = []
@@ -351,13 +324,8 @@ class VMExt:
         self._state = state
         self.get_code = state.get_code
         self.set_code = state.set_code
-        self.get_balances = state.get_balances  # gets token balances dict
-        self.get_balance = (
-            state.get_balance
-        )  # gets default_chain_token balance if no token_id is passed in
-        self.set_balances = state.set_balances  # sets token balances dict
-        self.set_token_balance = state.set_token_balance
-        self.set_balance = state.set_balance  # gets default_chain_token balance
+        self.get_balance = state.get_balance
+        self.set_balance = state.set_balance
         self.get_nonce = state.get_nonce
         self.set_nonce = state.set_nonce
         self.increment_nonce = state.increment_nonce
@@ -380,7 +348,13 @@ class VMExt:
         self.create = lambda msg: create_contract(self, msg)
         self.msg = lambda msg: _apply_msg(self, msg, self.get_code(msg.code_address))
         self.account_exists = state.account_exists
-        self.blockhash_store = 0x20
+        self.post_homestead_hardfork = lambda: state.is_HOMESTEAD()
+        self.post_metropolis_hardfork = lambda: state.is_METROPOLIS()
+        self.post_constantinople_hardfork = lambda: state.is_CONSTANTINOPLE()
+        self.post_serenity_hardfork = lambda: state.is_SERENITY()
+        self.post_anti_dos_hardfork = lambda: state.is_ANTI_DOS()
+        self.post_spurious_dragon_hardfork = lambda: state.is_SPURIOUS_DRAGON()
+        self.blockhash_store = state.config["METROPOLIS_BLOCKHASH_STORE"]
         self.snapshot = state.snapshot
         self.revert = state.revert
         self.transfer_value = state.transfer_value
@@ -391,8 +365,7 @@ class VMExt:
         self.reset_storage = state.reset_storage
         self.tx_origin = tx.sender if tx else b"\x00" * 20
         self.tx_gasprice = tx.gasprice if tx else 0
-        self.sender_disallow_map = state.sender_disallow_map
-        self.default_state_token = state.shard_config.default_chain_token
+        self.sender_disallow_list = state.sender_disallow_list
 
 
 def apply_msg(ext, msg):
@@ -415,23 +388,13 @@ def _apply_msg(ext, msg, code):
             pre_storage=ext.log_storage(msg.to),
             static=msg.static,
             depth=msg.depth,
-            gas_token_id=msg.gas_token_id,
-            transfer_token_id=msg.transfer_token_id,
         )
 
-    # early exit if msg.sender is disallowed
-    if (
-        msg.sender in ext.sender_disallow_map
-        and msg.value + ext.sender_disallow_map[msg.sender] > ext.get_balance(msg.sender)
-    ):
-        log_msg.warn("SENDER NOT ALLOWED", sender=encode_hex(msg.sender))
-        return 0, 0, []
-
     # transfer value, quit if not enough
     snapshot = ext.snapshot()
     if msg.transfers_value:
         if msg.is_cross_shard:
-            if not ext.deduct_value(msg.sender, msg.transfer_token_id, msg.value):
+            if not ext.deduct_value(msg.sender, msg.value):
                 return 1, msg.gas, []
             ext.add_cross_shard_transaction_deposit(
                 quarkchain.core.CrossShardTransactionDeposit(
@@ -442,17 +405,14 @@ def _apply_msg(ext, msg, code):
                     to_address=quarkchain.core.Address(msg.to, msg.to_full_shard_key),
                     value=msg.value,
                     gas_price=ext.tx_gasprice,
-                    gas_token_id=msg.gas_token_id,
-                    transfer_token_id=msg.transfer_token_id,
+                    # TODO: add gas_token_id and transfer_token_id to message
+                    gas_token_id=0,
+                    transfer_token_id=0,
                 )
             )
-        elif not ext.transfer_value(
-            msg.sender, msg.to, msg.transfer_token_id, msg.value
-        ):
+        elif not ext.transfer_value(msg.sender, msg.to, msg.value):
             log_msg.debug(
-                "MSG TRANSFER FAILED",
-                have=ext.get_balance(msg.sender, token_id=msg.transfer_token_id),
-                want=msg.value,
+                "MSG TRANSFER FAILED", have=ext.get_balance(msg.to), want=msg.value
             )
             return 1, msg.gas, []
 
@@ -460,10 +420,6 @@ def _apply_msg(ext, msg, code):
         # Cross shard contract call is not supported
         return 1, msg.gas, []
 
-    if msg.transfer_token_id != ext.default_state_token:
-        # TODODLL calling smart contract with non QKC transfer_token_id is not supported
-        return 1, msg.gas, []
-
     # Main loop
     if msg.code_address in ext.specials:
         res, gas, dat = ext.specials[msg.code_address](ext, msg)
@@ -488,9 +444,7 @@ def _apply_msg(ext, msg, code):
 
 
 def mk_contract_address(sender, full_shard_key, nonce):
-    return utils.sha3(
-        rlp.encode([utils.normalize_address(sender), full_shard_key, nonce])
-    )[12:]
+    return utils.sha3(rlp.encode([utils.normalize_address(sender), nonce]))[12:]
 
 
 def create_contract(ext, msg):
@@ -499,29 +453,27 @@ def create_contract(ext, msg):
     if msg.is_cross_shard:
         return 0, msg.gas, b""
 
-    if msg.transfer_token_id != ext.default_state_token:
-        # TODODLL calling smart contract with non QKC transfer_token_id is not supported
-        return 0, msg.gas, b""
-
     code = msg.data.extract_all()
 
     if ext.tx_origin != msg.sender:
         ext.increment_nonce(msg.sender)
 
-    if msg.sender == null_address:
+    if ext.post_constantinople_hardfork() and msg.sender == null_address:
         msg.to = mk_contract_address(msg.sender, msg.to_full_shard_key, 0)
         # msg.to = sha3(msg.sender + code)[12:]
     else:
         nonce = utils.encode_int(ext.get_nonce(msg.sender) - 1)
         msg.to = mk_contract_address(msg.sender, msg.to_full_shard_key, nonce)
 
-    if ext.get_nonce(msg.to) or len(ext.get_code(msg.to)):
+    if ext.post_metropolis_hardfork() and (
+        ext.get_nonce(msg.to) or len(ext.get_code(msg.to))
+    ):
         log_msg.debug("CREATING CONTRACT ON TOP OF EXISTING CONTRACT")
         return 0, 0, b""
 
-    b = ext.get_balances(msg.to)
-    if b != {}:
-        ext.set_balances(msg.to, b)
+    b = ext.get_balance(msg.to)
+    if b > 0:
+        ext.set_balance(msg.to, b)
         ext.set_nonce(msg.to, 0)
         ext.set_code(msg.to, b"")
         # ext.reset_storage(msg.to)
@@ -531,7 +483,7 @@ def create_contract(ext, msg):
     msg.data = vm.CallData([], 0, 0)
     snapshot = ext.snapshot()
 
-    ext.set_nonce(msg.to, 1)
+    ext.set_nonce(msg.to, 1 if ext.post_spurious_dragon_hardfork() else 0)
     res, gas, dat = _apply_msg(ext, msg, code)
 
     log_msg.debug(
@@ -546,7 +498,9 @@ def create_contract(ext, msg):
             # ext.set_code(msg.to, b'')
             return 1, gas, msg.to
         gcost = len(dat) * opcodes.GCONTRACTBYTE
-        if gas >= gcost and (len(dat) <= 24576):
+        if gas >= gcost and (
+            len(dat) <= 24576 or not ext.post_spurious_dragon_hardfork()
+        ):
             gas -= gcost
         else:
             dat = []
@@ -556,8 +510,9 @@ def create_contract(ext, msg):
                 want=gcost,
                 block_number=ext.block_number,
             )
-            ext.revert(snapshot)
-            return 0, 0, b""
+            if ext.post_homestead_hardfork():
+                ext.revert(snapshot)
+                return 0, 0, b""
         ext.set_code(msg.to, bytearray_to_bytestr(dat))
         log_msg.debug("SETTING CODE", addr=encode_hex(msg.to), lendat=len(dat))
         return 1, gas, msg.to
diff --git a/quarkchain/evm/specials.py b/quarkchain/evm/specials.py
index ac2406f..0f38d72 100644
--- a/quarkchain/evm/specials.py
+++ b/quarkchain/evm/specials.py
@@ -7,7 +7,7 @@ from quarkchain.evm import utils, opcodes
 from quarkchain.evm.utils import safe_ord, decode_hex, encode_int32
 
 
-ZERO_PRIVKEY_ADDR = decode_hex("3f17f1962b36e491b30a40b2405849e597ba5fb5")
+ZERO_PRIVKEY_ADDR = decode_hex('3f17f1962b36e491b30a40b2405849e597ba5fb5')
 
 
 def proc_ecrecover(ext, msg):
@@ -19,7 +19,7 @@ def proc_ecrecover(ext, msg):
 
     message_hash_bytes = [0] * 32
     msg.data.extract_copy(message_hash_bytes, 0, 0, 32)
-    message_hash = b"".join(map(ascii_chr, message_hash_bytes))
+    message_hash = b''.join(map(ascii_chr, message_hash_bytes))
 
     # TODO: This conversion isn't really necessary.
     # TODO: Invesitage if the check below is really needed.
@@ -39,9 +39,8 @@ def proc_ecrecover(ext, msg):
 
 def proc_sha256(ext, msg):
     # print('sha256 proc', msg.gas)
-    OP_GAS = (
-        opcodes.GSHA256BASE + (utils.ceil32(msg.data.size) // 32) * opcodes.GSHA256WORD
-    )
+    OP_GAS = opcodes.GSHA256BASE + \
+        (utils.ceil32(msg.data.size) // 32) * opcodes.GSHA256WORD
     gas_cost = OP_GAS
     if msg.gas < gas_cost:
         return 0, 0, []
@@ -52,23 +51,20 @@ def proc_sha256(ext, msg):
 
 def proc_ripemd160(ext, msg):
     # print('ripemd160 proc', msg.gas)
-    OP_GAS = (
-        opcodes.GRIPEMD160BASE
-        + (utils.ceil32(msg.data.size) // 32) * opcodes.GRIPEMD160WORD
-    )
+    OP_GAS = opcodes.GRIPEMD160BASE + \
+        (utils.ceil32(msg.data.size) // 32) * opcodes.GRIPEMD160WORD
     gas_cost = OP_GAS
     if msg.gas < gas_cost:
         return 0, 0, []
     d = msg.data.extract_all()
-    o = [0] * 12 + [safe_ord(x) for x in hashlib.new("ripemd160", d).digest()]
+    o = [0] * 12 + [safe_ord(x) for x in hashlib.new('ripemd160', d).digest()]
     return 1, msg.gas - gas_cost, o
 
 
 def proc_identity(ext, msg):
-    # print('identity proc', msg.gas)
-    OP_GAS = opcodes.GIDENTITYBASE + opcodes.GIDENTITYWORD * (
-        utils.ceil32(msg.data.size) // 32
-    )
+    #print('identity proc', msg.gas)
+    OP_GAS = opcodes.GIDENTITYBASE + \
+        opcodes.GIDENTITYWORD * (utils.ceil32(msg.data.size) // 32)
     gas_cost = OP_GAS
     if msg.gas < gas_cost:
         return 0, 0, []
@@ -87,20 +83,22 @@ def mult_complexity(x):
 
 
 def proc_modexp(ext, msg):
-    print("modexp proc", msg.gas)
+    if not ext.post_metropolis_hardfork():
+        return 1, msg.gas, []
+    print('modexp proc', msg.gas)
     baselen = msg.data.extract32(0)
     explen = msg.data.extract32(32)
     modlen = msg.data.extract32(64)
-    first_exp_bytes = msg.data.extract32(96 + baselen) >> (8 * max(32 - explen, 0))
+    first_exp_bytes = msg.data.extract32(
+        96 + baselen) >> (8 * max(32 - explen, 0))
     bitlength = -1
     while first_exp_bytes:
         bitlength += 1
         first_exp_bytes >>= 1
     adjusted_explen = max(bitlength, 0) + 8 * max(explen - 32, 0)
-    gas_cost = (
-        mult_complexity(max(modlen, baselen)) * max(adjusted_explen, 1)
-    ) // opcodes.GMODEXPQUADDIVISOR
-    print(baselen, explen, modlen, "expected gas cost", gas_cost)
+    gas_cost = (mult_complexity(max(modlen, baselen)) *
+                max(adjusted_explen, 1)) // opcodes.GMODEXPQUADDIVISOR
+    print(baselen, explen, modlen, 'expected gas cost', gas_cost)
     if msg.gas < gas_cost:
         return 0, 0, []
     if baselen == 0:
@@ -118,18 +116,15 @@ def proc_modexp(ext, msg):
     o = pow(
         utils.big_endian_to_int(base),
         utils.big_endian_to_int(exp),
-        utils.big_endian_to_int(mod),
-    )
-    return (
-        1,
-        msg.gas - gas_cost,
-        [safe_ord(x) for x in utils.zpad(utils.int_to_big_endian(o), modlen)],
-    )
+        utils.big_endian_to_int(mod))
+    return 1, msg.gas - \
+        gas_cost, [
+            safe_ord(x) for x in utils.zpad(
+                utils.int_to_big_endian(o), modlen)]
 
 
 def validate_point(x, y):
     import py_ecc.optimized_bn128 as bn128
-
     FQ = bn128.FQ
     if x >= bn128.field_modulus or y >= bn128.field_modulus:
         return False
@@ -143,10 +138,11 @@ def validate_point(x, y):
 
 
 def proc_ecadd(ext, msg):
+    if not ext.post_metropolis_hardfork():
+        return 1, msg.gas, []
     import py_ecc.optimized_bn128 as bn128
-
     FQ = bn128.FQ
-    print("ecadd proc:", msg.gas)
+    print('ecadd proc:', msg.gas)
     if msg.gas < opcodes.GECADD:
         return 0, 0, []
     x1 = msg.data.extract32(0)
@@ -158,18 +154,17 @@ def proc_ecadd(ext, msg):
     if p1 is False or p2 is False:
         return 0, 0, []
     o = bn128.normalize(bn128.add(p1, p2))
-    return (
-        1,
-        msg.gas - opcodes.GECADD,
-        [safe_ord(x) for x in (encode_int32(o[0].n) + encode_int32(o[1].n))],
-    )
+    return 1, msg.gas - \
+        opcodes.GECADD, [safe_ord(x) for x in (
+            encode_int32(o[0].n) + encode_int32(o[1].n))]
 
 
 def proc_ecmul(ext, msg):
+    if not ext.post_metropolis_hardfork():
+        return 1, msg.gas, []
     import py_ecc.optimized_bn128 as bn128
-
     FQ = bn128.FQ
-    print("ecmul proc", msg.gas)
+    print('ecmul proc', msg.gas)
     if msg.gas < opcodes.GECMUL:
         return 0, 0, []
     x = msg.data.extract32(0)
@@ -179,18 +174,16 @@ def proc_ecmul(ext, msg):
     if p is False:
         return 0, 0, []
     o = bn128.normalize(bn128.multiply(p, m))
-    return (
-        1,
-        msg.gas - opcodes.GECMUL,
-        [safe_ord(c) for c in (encode_int32(o[0].n) + encode_int32(o[1].n))],
-    )
+    return (1, msg.gas - opcodes.GECMUL,
+            [safe_ord(c) for c in (encode_int32(o[0].n) + encode_int32(o[1].n))])
 
 
 def proc_ecpairing(ext, msg):
+    if not ext.post_metropolis_hardfork():
+        return 1, msg.gas, []
     import py_ecc.optimized_bn128 as bn128
-
     FQ = bn128.FQ
-    print("pairing proc", msg.gas)
+    print('pairing proc', msg.gas)
     # Data must be an exact multiple of 192 byte
     if msg.data.size % 192:
         return 0, 0, []
@@ -228,23 +221,21 @@ def proc_ecpairing(ext, msg):
 
 
 specials = {
-    decode_hex(k): v
-    for k, v in {
-        b"0000000000000000000000000000000000000001": proc_ecrecover,
-        b"0000000000000000000000000000000000000002": proc_sha256,
-        b"0000000000000000000000000000000000000003": proc_ripemd160,
-        b"0000000000000000000000000000000000000004": proc_identity,
-        b"0000000000000000000000000000000000000005": proc_modexp,
-        b"0000000000000000000000000000000000000006": proc_ecadd,
-        b"0000000000000000000000000000000000000007": proc_ecmul,
-        b"0000000000000000000000000000000000000008": proc_ecpairing,
+    decode_hex(k): v for k, v in
+    {
+        b'0000000000000000000000000000000000000001': proc_ecrecover,
+        b'0000000000000000000000000000000000000002': proc_sha256,
+        b'0000000000000000000000000000000000000003': proc_ripemd160,
+        b'0000000000000000000000000000000000000004': proc_identity,
+        b'0000000000000000000000000000000000000005': proc_modexp,
+        b'0000000000000000000000000000000000000006': proc_ecadd,
+        b'0000000000000000000000000000000000000007': proc_ecmul,
+        b'0000000000000000000000000000000000000008': proc_ecpairing,
     }.items()
 }
 
-if __name__ == "__main__":
-
+if __name__ == '__main__':
     class msg(object):
-        data = "testdata"
+        data = 'testdata'
         gas = 500
-
     proc_ripemd160(None, msg)
diff --git a/quarkchain/evm/state.py b/quarkchain/evm/state.py
index d406c28..350e5c6 100644
--- a/quarkchain/evm/state.py
+++ b/quarkchain/evm/state.py
@@ -4,7 +4,6 @@ from typing import Set
 import rlp
 from rlp.sedes.lists import CountableList
 from rlp.sedes import binary
-from quarkchain.config import ChainConfig, ShardConfig
 from quarkchain.evm.utils import (
     hash32,
     trie_root,
@@ -52,7 +51,7 @@ STATE_DEFAULTS = {
     "block_number": 0,
     "block_coinbase": b"\x00" * 20,
     "block_difficulty": 1,
-    "block_fee_tokens": {},
+    "block_fee": 0,
     "timestamp": 0,
     "logs": [],
     "receipts": [],
@@ -63,18 +62,16 @@ STATE_DEFAULTS = {
     "refunds": 0,
     "xshard_list": [],
     "full_shard_key": 0,  # should be updated before applying each tx
-    "xshard_tx_cursor_info": None,
+    "xshard_tx_cursor_info": None
 }
 
 
 class _Account(rlp.Serializable):
     fields = [
         ("nonce", big_endian_int),
-        ("token_balances", binary),
+        ("balance", big_endian_int),
         ("storage", trie_root),
         ("code_hash", hash32),
-        ("full_shard_key", BigEndianInt(4)),
-        ("optional", binary),
     ]
 
 
@@ -84,7 +81,7 @@ class TokenBalancePair(rlp.Serializable):
 
 class TokenBalances:
     """interface for token balances
-    TODODLL: store token balances in trie when TOKEN_TRIE_THRESHOLD is crossed
+    TODO: store token balances in trie when TOKEN_TRIE_THRESHOLD is crossed
     """
 
     def __init__(self, data: bytes, db):
@@ -102,8 +99,6 @@ class TokenBalances:
                 raise Exception("Unknown enum byte in token_balances")
 
     def serialize(self):
-        if len(self.balances) == 0:
-            return b""
         retv = self.enum
         if self.enum == b"\x00":
             l = []
@@ -119,22 +114,22 @@ class TokenBalances:
         return retv
 
     def balance(self, token_id):
-        return self.balances.get(token_id, 0)
+        self.balances.get(token_id, 0)
 
-    def is_empty(self):
-        return all(v == 0 for v in self.balances.values())
+    def delta(self, token_id, value):
+        self.balances[token_id] = self.balances.get(token_id, 0) + value
 
 
 class Account:
     def __init__(
         self,
         nonce,
-        token_balances,
+        balance,
         storage,
         code_hash,
-        full_shard_key,
-        env,
-        address,
+        full_shard_key=0,
+        env=None,
+        address=None,
         db=None,
     ):
         self.db = env.db if db is None else db
@@ -142,12 +137,12 @@ class Account:
         self.env = env
         self.address = address
 
-        acc = _Account(nonce, token_balances, storage, code_hash, full_shard_key, b"")
+        acc = _Account(nonce, balance, storage, code_hash)
         self.nonce = acc.nonce
+        self.balance = acc.balance
         self.storage = acc.storage
         self.code_hash = acc.code_hash
-        self.full_shard_key = acc.full_shard_key
-        self.token_balances = TokenBalances(token_balances, self.db)
+        self.full_shard_key = full_shard_key
 
         self.storage_cache = {}
         self.storage_trie = SecureTrie(Trie(self.db))
@@ -196,7 +191,7 @@ class Account:
         db.put(BLANK_HASH, b"")
         o = cls(
             initial_nonce,
-            b"",
+            0,
             trie.BLANK_ROOT,
             BLANK_HASH,
             full_shard_key,
@@ -208,11 +203,7 @@ class Account:
         return o
 
     def is_blank(self):
-        return (
-            self.nonce == 0
-            and self.token_balances.is_empty()
-            and self.code_hash == BLANK_HASH
-        )
+        return self.nonce == 0 and self.balance == 0 and self.code_hash == BLANK_HASH
 
     @property
     def exists(self):
@@ -225,7 +216,7 @@ class Account:
         for k, v in self.storage_cache.items():
             odict[utils.encode_int(k)] = rlp.encode(utils.encode_int(v))
         return {
-            "token_balances": str(self.token_balances.balances),
+            "balance": str(self.balance),
             "nonce": str(self.nonce),
             "code": "0x" + encode_hex(self.code),
             "storage": {
@@ -262,8 +253,7 @@ class State:
         self.changed = {}
         self.executing_on_head = executing_on_head
         self.qkc_config = qkc_config
-        self.sender_disallow_map = dict()  # type: Dict[bytes, int]
-        self.shard_config = ShardConfig(ChainConfig())
+        self.sender_disallow_list = set()  # type: Set[bytes]
 
     @property
     def db(self):
@@ -301,10 +291,9 @@ class State:
             o = rlp.decode(rlpdata, _Account)
             o = Account(
                 nonce=o.nonce,
-                token_balances=o.token_balances,
+                balance=o.balance,
                 storage=o.storage,
                 code_hash=o.code_hash,
-                full_shard_key=o.full_shard_key,
                 env=self.env,
                 address=address,
                 db=self.db,
@@ -322,17 +311,8 @@ class State:
         o._cached_rlp = None
         return o
 
-    def get_balances(self, address) -> dict:
-        return self.get_and_cache_account(
-            utils.normalize_address(address)
-        ).token_balances.balances
-
-    def get_balance(self, address, token_id=None):
-        if token_id is None:
-            token_id = self.shard_config.default_chain_token
-        return self.get_and_cache_account(
-            utils.normalize_address(address)
-        ).token_balances.balance(token_id)
+    def get_balance(self, address):
+        return self.get_and_cache_account(utils.normalize_address(address)).balance
 
     def get_code(self, address):
         return self.get_and_cache_account(utils.normalize_address(address)).code
@@ -351,12 +331,9 @@ class State:
         self.journal.append(lambda: setattr(acct, param, preval))
         setattr(acct, param, val)
 
-    def set_balances(self, address, token_balances: dict):
+    def set_balance(self, address, value):
         acct = self.get_and_cache_account(utils.normalize_address(address))
-        if self.get_balances(address) == token_balances:
-            self.set_and_journal(acct, "touched", True)
-            return
-        self.set_and_journal(acct.token_balances, "balances", token_balances)
+        self.set_and_journal(acct, "balance", value)
         self.set_and_journal(acct, "touched", True)
 
     def set_code(self, address, value):
@@ -370,39 +347,11 @@ class State:
         self.set_and_journal(acct, "nonce", value)
         self.set_and_journal(acct, "touched", True)
 
-    def set_token_balance(self, address, token_id, val):
-        acct = self.get_and_cache_account(utils.normalize_address(address))
-        if val == self.get_balance(address, token_id=token_id):
-            self.set_and_journal(acct, "touched", True)
-            return
-        self._set_token_balance_and_journal(acct, token_id, val)
-        self.set_and_journal(acct, "touched", True)
-
-    def set_balance(self, address, val):
-        self.set_token_balance(
-            address, token_id=self.shard_config.default_chain_token, val=val
-        )
-
-    def _set_token_balance_and_journal(self, acct, token_id, val):
-        """if token_id was not set, journal will erase token_id when reverted
-        """
-        preval = acct.token_balances.balances.get(token_id, None)
-        if preval == None:
-            self.journal.append(lambda: acct.token_balances.balances.pop(token_id))
-        else:
-            self.journal.append(
-                lambda: acct.token_balances.balances.__setitem__(token_id, preval)
-            )
-        acct.token_balances.balances[token_id] = val
-
-    def delta_token_balance(self, address, token_id, value):
+    def delta_balance(self, address, value):
         address = utils.normalize_address(address)
         acct = self.get_and_cache_account(address)
-        if value == 0:
-            self.set_and_journal(acct, "touched", True)
-            return
-        newbal = acct.token_balances.balance(token_id) + value
-        self._set_token_balance_and_journal(acct, token_id, newbal)
+        newbal = acct.balance + value
+        self.set_and_journal(acct, "balance", newbal)
         self.set_and_journal(acct, "touched", True)
 
     def increment_nonce(self, address):
@@ -469,29 +418,82 @@ class State:
         if (
             three_touched and 2675000 < self.block_number < 2675200
         ):  # Compatibility with weird geth+parity bug
-            self.delta_token_balance(THREE, self.shard_config.default_chain_token, 0)
+            self.delta_balance(THREE, 0)
 
     def set_param(self, k, v):
         preval = getattr(self, k)
         self.journal.append(lambda: setattr(self, k, preval))
         setattr(self, k, v)
 
+    def is_SERENITY(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["SERENITY_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["SERENITY_FORK_BLKNUM"]
+
+    def is_HOMESTEAD(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["HOMESTEAD_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["HOMESTEAD_FORK_BLKNUM"]
+
+    def is_METROPOLIS(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["METROPOLIS_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["METROPOLIS_FORK_BLKNUM"]
+
+    def is_CONSTANTINOPLE(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["CONSTANTINOPLE_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["CONSTANTINOPLE_FORK_BLKNUM"]
+
+    def is_ANTI_DOS(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["ANTI_DOS_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["ANTI_DOS_FORK_BLKNUM"]
+
+    def is_SPURIOUS_DRAGON(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["SPURIOUS_DRAGON_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["SPURIOUS_DRAGON_FORK_BLKNUM"]
+
+    def is_DAO(self, at_fork_height=False):
+        if at_fork_height:
+            return self.block_number == self.config["DAO_FORK_BLKNUM"]
+        else:
+            return self.block_number >= self.config["DAO_FORK_BLKNUM"]
+
     def account_exists(self, address):
-        o = not self.get_and_cache_account(utils.normalize_address(address)).is_blank()
+        if self.is_SPURIOUS_DRAGON():
+            o = not self.get_and_cache_account(
+                utils.normalize_address(address)
+            ).is_blank()
+        else:
+            a = self.get_and_cache_account(address)
+            if a.deleted and not a.touched:
+                return False
+            if a.touched:
+                return True
+            else:
+                return a.existent_at_start
         return o
 
-    def transfer_value(self, from_addr, to_addr, token_id, value):
+    def transfer_value(self, from_addr, to_addr, value):
         assert value >= 0
-        if self.get_balance(from_addr, token_id=token_id) >= value:
-            self.delta_token_balance(from_addr, token_id, -value)
-            self.delta_token_balance(to_addr, token_id, value)
+        if self.get_balance(from_addr) >= value:
+            self.delta_balance(from_addr, -value)
+            self.delta_balance(to_addr, value)
             return True
         return False
 
-    def deduct_value(self, from_addr, token_id, value):
+    def deduct_value(self, from_addr, value):
         assert value >= 0
-        if self.get_balance(from_addr, token_id=token_id) >= value:
-            self.delta_token_balance(from_addr, token_id, -value)
+        if self.get_balance(from_addr) >= value:
+            self.delta_balance(from_addr, -value)
             return True
         return False
 
@@ -506,12 +508,7 @@ class State:
                 self.changed[addr] = True
                 if self.account_exists(addr) or allow_empties:
                     _acct = _Account(
-                        acct.nonce,
-                        acct.token_balances.serialize(),
-                        acct.storage,
-                        acct.code_hash,
-                        acct.full_shard_key,
-                        b"",
+                        acct.nonce, acct.balance, acct.storage, acct.code_hash
                     )
                     self.trie.update(addr, rlp.encode(_acct))
                     if self.executing_on_head:
@@ -534,7 +531,7 @@ class State:
         return {encode_hex(addr): acct.to_dict() for addr, acct in self.cache.items()}
 
     def del_account(self, address):
-        self.set_balances(address, {})
+        self.set_balance(address, 0)
         self.set_nonce(address, 0)
         self.set_code(address, b"")
         self.reset_storage(address)
@@ -599,9 +596,9 @@ class State:
                     addr = decode_hex(addr)
                 assert len(addr) == 20
                 if "wei" in data:
-                    state.set_balances(addr, eval(data["wei"]))
-                if "token_balances" in data:
-                    state.set_balances(addr, eval(data["token_balances"]))
+                    state.set_balance(addr, parse_as_int(data["wei"]))
+                if "balance" in data:
+                    state.set_balance(addr, parse_as_int(data["balance"]))
                 if "code" in data:
                     state.set_code(addr, parse_as_bin(data["code"]))
                 if "nonce" in data:
@@ -659,7 +656,7 @@ class State:
         s.journal = copy.copy(self.journal)
         s.cache = {}
         s.qkc_config = self.qkc_config
-        s.sender_disallow_map = self.sender_disallow_map
+        s.sender_disallow_list = self.sender_disallow_list
         return s
 
 
diff --git a/quarkchain/evm/transactions.py b/quarkchain/evm/transactions.py
index d6b9de5..9d6d8fb 100644
--- a/quarkchain/evm/transactions.py
+++ b/quarkchain/evm/transactions.py
@@ -85,8 +85,6 @@ class Transaction(rlp.Serializable):
         to,
         value,
         data,
-        gas_token_id,
-        transfer_token_id,
         v=0,
         r=0,
         s=0,
@@ -94,6 +92,8 @@ class Transaction(rlp.Serializable):
         to_full_shard_key=0,
         network_id=1,
         version=0,
+        gas_token_id=0,
+        transfer_token_id=0,
     ):
         self.quark_chain_config = None
 
@@ -252,10 +252,7 @@ class Transaction(rlp.Serializable):
 
     @property
     def is_cross_shard(self):
-        return (
-            self.from_chain_id != self.to_chain_id
-            or self.from_shard_id != self.to_shard_id
-        )
+        return False
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.hash == other.hash
@@ -275,6 +272,17 @@ class Transaction(rlp.Serializable):
     def __structlog__(self):
         return encode_hex(self.hash)
 
+    # This method should be called for block numbers >= HOMESTEAD_FORK_BLKNUM only.
+    # The >= operator is replaced by > because the integer division N/2 always produces the value
+    # which is by 0.5 less than the real N/2
+    def check_low_s_metropolis(self):
+        if self.s > secpk1n // 2:
+            raise InvalidTransaction("Invalid signature S value!")
+
+    def check_low_s_homestead(self):
+        if self.s > secpk1n // 2 or self.s == 0:
+            raise InvalidTransaction("Invalid signature S value!")
+
 
 class UnsignedTransaction(rlp.Serializable):
     fields = [
diff --git a/quarkchain/evm/vm.py b/quarkchain/evm/vm.py
index 0f36acc..3b8cbaa 100644
--- a/quarkchain/evm/vm.py
+++ b/quarkchain/evm/vm.py
@@ -275,6 +275,10 @@ def vm_trace(ext, msg, compustate, opcode, pushcache, tracer=log_vm_op):
 # Main function
 def vm_execute(ext, msg, code):
 
+    # early exit if msg.sender is disallowed
+    if msg.sender in ext.sender_disallow_list:
+        return vm_exception("SENDER NOT ALLOWED")
+
     # precompute trace flag
     # if we trace vm, we're in slow mode anyway
     trace_vm = log_vm_op.is_active("trace")
@@ -300,6 +304,9 @@ def vm_execute(ext, msg, code):
         if opcode not in opcodes.opcodes:
             return vm_exception("INVALID OP", opcode=opcode)
 
+        if opcode in opcodes.opcodesMetropolis and not ext.post_metropolis_hardfork():
+            return vm_exception("INVALID OP (not yet enabled)", opcode=opcode)
+
         op, in_args, out_args, fee = opcodes.opcodes[opcode]
 
         # Apply operation
@@ -423,7 +430,8 @@ def vm_execute(ext, msg, code):
                 # calc n bytes to represent exponent
                 nbytes = len(utils.encode_int(exponent))
                 expfee = nbytes * opcodes.GEXPONENTBYTE
-                expfee += opcodes.EXP_SUPPLEMENTAL_GAS * nbytes
+                if ext.post_spurious_dragon_hardfork():
+                    expfee += opcodes.EXP_SUPPLEMENTAL_GAS * nbytes
                 if compustate.gas < expfee:
                     compustate.gas = 0
                     return vm_exception("OOG EXPONENT")
@@ -483,8 +491,9 @@ def vm_execute(ext, msg, code):
             elif op == "ADDRESS":
                 stk.append(utils.coerce_to_int(msg.to))
             elif op == "BALANCE":
-                if not eat_gas(compustate, opcodes.BALANCE_SUPPLEMENTAL_GAS):
-                    return vm_exception("OUT OF GAS")
+                if ext.post_anti_dos_hardfork():
+                    if not eat_gas(compustate, opcodes.BALANCE_SUPPLEMENTAL_GAS):
+                        return vm_exception("OUT OF GAS")
                 addr = utils.coerce_addr_to_hex(stk.pop() % 2 ** 160)
                 stk.append(ext.get_balance(addr))
             elif op == "ORIGIN":
@@ -533,13 +542,15 @@ def vm_execute(ext, msg, code):
             elif op == "GASPRICE":
                 stk.append(ext.tx_gasprice)
             elif op == "EXTCODESIZE":
-                if not eat_gas(compustate, opcodes.EXTCODELOAD_SUPPLEMENTAL_GAS):
-                    return vm_exception("OUT OF GAS")
+                if ext.post_anti_dos_hardfork():
+                    if not eat_gas(compustate, opcodes.EXTCODELOAD_SUPPLEMENTAL_GAS):
+                        return vm_exception("OUT OF GAS")
                 addr = utils.coerce_addr_to_hex(stk.pop() % 2 ** 160)
                 stk.append(len(ext.get_code(addr) or b""))
             elif op == "EXTCODECOPY":
-                if not eat_gas(compustate, opcodes.EXTCODELOAD_SUPPLEMENTAL_GAS):
-                    return vm_exception("OUT OF GAS")
+                if ext.post_anti_dos_hardfork():
+                    if not eat_gas(compustate, opcodes.EXTCODELOAD_SUPPLEMENTAL_GAS):
+                        return vm_exception("OUT OF GAS")
                 addr = utils.coerce_addr_to_hex(stk.pop() % 2 ** 160)
                 start, s2, size = stk.pop(), stk.pop(), stk.pop()
                 extcode = ext.get_code(addr) or b""
@@ -556,7 +567,11 @@ def vm_execute(ext, msg, code):
         # Block info
         elif opcode < 0x50:
             if op == "BLOCKHASH":
-                stk.append(utils.big_endian_to_int(ext.block_hash(stk.pop())))
+                if ext.post_constantinople_hardfork() and False:
+                    bh_addr = ext.blockhash_store
+                    stk.append(ext.get_storage_data(bh_addr, stk.pop()))
+                else:
+                    stk.append(utils.big_endian_to_int(ext.block_hash(stk.pop())))
             elif op == "COINBASE":
                 stk.append(utils.big_endian_to_int(ext.block_coinbase))
             elif op == "TIMESTAMP":
@@ -587,8 +602,9 @@ def vm_execute(ext, msg, code):
                     return vm_exception("OOG EXTENDING MEMORY")
                 mem[s0] = s1 % 256
             elif op == "SLOAD":
-                if not eat_gas(compustate, opcodes.SLOAD_SUPPLEMENTAL_GAS):
-                    return vm_exception("OUT OF GAS")
+                if ext.post_anti_dos_hardfork():
+                    if not eat_gas(compustate, opcodes.SLOAD_SUPPLEMENTAL_GAS):
+                        return vm_exception("OUT OF GAS")
                 stk.append(ext.get_storage_data(msg.to, stk.pop()))
             elif op == "SSTORE":
                 s0, s1 = stk.pop(), stk.pop()
@@ -674,7 +690,8 @@ def vm_execute(ext, msg, code):
             if ext.get_balance(msg.to) >= value and msg.depth < MAX_DEPTH:
                 cd = CallData(mem, mstart, msz)
                 ingas = compustate.gas
-                ingas = all_but_1n(ingas, opcodes.CALL_CHILD_LIMIT_DENOM)
+                if ext.post_anti_dos_hardfork():
+                    ingas = all_but_1n(ingas, opcodes.CALL_CHILD_LIMIT_DENOM)
                 create_msg = Message(
                     msg.to,
                     b"",
@@ -732,20 +749,31 @@ def vm_execute(ext, msg, code):
             # Extra gas costs based on various factors
             extra_gas = 0
             # Creating a new account
-            if op == "CALL" and not ext.account_exists(to) and (value > 0):
+            if (
+                op == "CALL"
+                and not ext.account_exists(to)
+                and (value > 0 or not ext.post_spurious_dragon_hardfork())
+            ):
                 extra_gas += opcodes.GCALLNEWACCOUNT
             # Value transfer
             if value > 0:
                 extra_gas += opcodes.GCALLVALUETRANSFER
             # Cost increased from 40 to 700 in Tangerine Whistle
-            extra_gas += opcodes.CALL_SUPPLEMENTAL_GAS
+            if ext.post_anti_dos_hardfork():
+                extra_gas += opcodes.CALL_SUPPLEMENTAL_GAS
             # Compute child gas limit
-            if compustate.gas < extra_gas:
-                return vm_exception("OUT OF GAS", needed=extra_gas)
-            gas = min(
-                gas,
-                all_but_1n(compustate.gas - extra_gas, opcodes.CALL_CHILD_LIMIT_DENOM),
-            )
+            if ext.post_anti_dos_hardfork():
+                if compustate.gas < extra_gas:
+                    return vm_exception("OUT OF GAS", needed=extra_gas)
+                gas = min(
+                    gas,
+                    all_but_1n(
+                        compustate.gas - extra_gas, opcodes.CALL_CHILD_LIMIT_DENOM
+                    ),
+                )
+            else:
+                if compustate.gas < gas + extra_gas:
+                    return vm_exception("OUT OF GAS", needed=gas + extra_gas)
             submsg_gas = gas + opcodes.GSTIPEND * (value > 0)
             # Verify that there is sufficient balance and depth
             if ext.get_balance(msg.to) < value or msg.depth >= MAX_DEPTH:
@@ -769,7 +797,7 @@ def vm_execute(ext, msg, code):
                         code_address=to,
                         static=msg.static,
                     )
-                elif op == "DELEGATECALL":
+                elif ext.post_homestead_hardfork() and op == "DELEGATECALL":
                     call_msg = Message(
                         msg.sender,
                         msg.to,
@@ -781,7 +809,7 @@ def vm_execute(ext, msg, code):
                         transfers_value=False,
                         static=msg.static,
                     )
-                elif op == "STATICCALL":
+                elif ext.post_metropolis_hardfork() and op == "STATICCALL":
                     call_msg = Message(
                         msg.to,
                         to,
@@ -826,6 +854,8 @@ def vm_execute(ext, msg, code):
             return peaceful_exit("RETURN", compustate.gas, mem[s0 : s0 + s1])
         # Revert opcode (Metropolis)
         elif op == "REVERT":
+            if not ext.post_metropolis_hardfork():
+                return vm_exception("Opcode not yet enabled")
             s0, s1 = stk.pop(), stk.pop()
             if not mem_extend(mem, compustate, op, s0, s1):
                 return vm_exception("OOG EXTENDING MEMORY")
@@ -837,12 +867,15 @@ def vm_execute(ext, msg, code):
             to = utils.encode_int(stk.pop())
             to = ((b"\x00" * (32 - len(to))) + to)[12:]
             xfer = ext.get_balance(msg.to)
-            extra_gas = (
-                opcodes.SUICIDE_SUPPLEMENTAL_GAS
-                + (not ext.account_exists(to)) * (xfer > 0) * opcodes.GCALLNEWACCOUNT
-            )
-            if not eat_gas(compustate, extra_gas):
-                return vm_exception("OUT OF GAS")
+            if ext.post_anti_dos_hardfork():
+                extra_gas = (
+                    opcodes.SUICIDE_SUPPLEMENTAL_GAS
+                    + (not ext.account_exists(to))
+                    * (xfer > 0 or not ext.post_spurious_dragon_hardfork())
+                    * opcodes.GCALLNEWACCOUNT
+                )
+                if not eat_gas(compustate, extra_gas):
+                    return vm_exception("OUT OF GAS")
             ext.set_balance(to, ext.get_balance(to) + xfer)
             ext.set_balance(msg.to, 0)
             ext.add_suicide(msg.to)
